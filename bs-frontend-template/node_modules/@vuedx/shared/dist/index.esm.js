import Path from 'path';
import { init, getCurrentHub, startTransaction, configureScope, captureMessage, Severity, captureEvent, captureException } from '@sentry/node';
import { machineSync } from 'node-unique-machine-id';
import os from 'os';
import { v4 } from 'uuid';

function isNotNull(value) {
    return value != null;
}

function isArray(value) {
    return Array.isArray(value);
}
function first(items) {
    return items[0];
}
function last(items, nth = 1) {
    return items[items.length - nth];
}
function findPrevSibling(items, item) {
    const index = items.indexOf(item);
    if (index > 0)
        return items[index - 1];
}
function findNextSibling(items, item) {
    const index = items.indexOf(item);
    if (index >= 0)
        return items[index + 1];
}
function concat(a, b) {
    const c = [];
    if (isArray(a))
        c.push(...a);
    if (isArray(b))
        c.push(...b);
    return c;
}

function isString(value) {
    return typeof value === 'string';
}
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit !== null && hit !== void 0 ? hit : (cache[str] = fn(str));
    });
};
const camelizeRE = /[^A-Za-z0-9]+([A-Za-z0-9])/g;
const camelize = cacheStringFunction((str) => {
    return uncapitalize(str.replace(camelizeRE, (_, c) => typeof c === 'string' ? c.toUpperCase() : ''));
});
const camelCase = camelize;
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => {
    return camelize(str).replace(hyphenateRE, '-$1').toLowerCase();
});
const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
const uncapitalize = cacheStringFunction((str) => {
    return str.charAt(0).toLowerCase() + str.slice(1);
});
const pascalCase = cacheStringFunction((str) => capitalize(camelize(str)));
const kebabCase = hyphenate;
function isKebabCase(str) {
    return str.includes('-');
}
function isPascalCase(str) {
    return /^[A-Z][A-Za-z0-9]*$/.test(str);
}
function isCamelCase(str) {
    return /^[a-z][A-Za-z0-9]*$/.test(str);
}

function getComponentName(fileName) {
    return pascalCase(Path.posix.basename(fileName).replace(/\.(vue|ts|tsx|js|jsx)$/, ''));
}
function getComponentNameAliases(fileNameOrComponentName) {
    const name = Path.posix
        .basename(fileNameOrComponentName)
        .replace(/\.(vue|ts|tsx|js|jsx)$/, '');
    return isKebabCase(name)
        ? [kebabCase(name)]
        : [kebabCase(name), pascalCase(name)];
}

function isNumber(value) {
    return typeof value === 'number' && !Number.isNaN(value);
}

function getRelativeFileName(importingFileName, importedFileName) {
    if (Path.posix.isAbsolute(importingFileName) &&
        Path.posix.isAbsolute(importedFileName)) {
        const fileName = Path.posix.relative(Path.posix.dirname(importingFileName), importedFileName);
        return fileName.startsWith('.') ? fileName : `./${fileName}`;
    }
    return importedFileName;
}

class Telemetry {
    constructor(key, options, defaults) {
        var _a, _b;
        this.user = {
            id: this.getUserId(),
        };
        this.optOut = 
            ((_a = process.env.VUEDX_TELEMETRY) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'off' ||
            ((_b = process.env.VUEDX_TELEMETRY) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'false';
        init({
            dsn: key,
            defaultIntegrations: false,
            release: options.release,
            environment: options.environment,
            tracesSampleRate: options.tracesSampleRate,
        });
        this.defaults = {
            sessionId: v4(),
            nodeVersion: process.version,
            os: os.platform(),
            ...defaults,
        };
    }
    getUserId() {
        try {
            return machineSync(false, true);
        }
        catch (_a) {
            return '';
        }
    }
    trace(name, description) {
        var _a;
        if (this.optOut)
            return () => { };
        const activeTransaction = (_a = getCurrentHub()
            .getScope()) === null || _a === void 0 ? void 0 : _a.getTransaction();
        if (activeTransaction == null) {
            const transaction = startTransaction({
                name,
                description,
            });
            configureScope((scope) => {
                scope.setSpan(transaction);
            });
            return () => {
                captureMessage(`[trace] ${name}`, (scope) => {
                    scope.setSpan(transaction);
                    scope.setUser(this.user);
                    scope.setTags({ ...this.defaults });
                    scope.setLevel(Severity.Info);
                    return scope;
                });
                transaction.finish();
                configureScope((scope) => {
                    scope.setSpan(undefined);
                });
            };
        }
        else {
            const child = activeTransaction.startChild({
                op: name,
                description,
            });
            return () => {
                child.finish();
            };
        }
    }
    collect(key, value) {
        if (this.optOut)
            return;
        const tags = {};
        const allowed = new Set(['string', 'number', 'boolean']);
        Object.entries(value).forEach(([key, value]) => {
            if (allowed.has(typeof value)) {
                tags[`data_${key}`] = value;
            }
        });
        captureEvent({
            message: `${key}`,
            level: Severity.Info,
            user: this.user,
            tags: {
                ...this.defaults,
                ...tags,
            },
            extra: value,
        });
    }
    error(payload) {
        if (this.optOut)
            return;
        if (typeof payload === 'string') {
            payload = new Error(payload);
        }
        void captureException(payload, {
            level: Severity.Fatal,
            user: this.user,
            tags: {
                ...this.defaults,
            },
        });
    }
    static get instance() {
        if (this._instance == null) {
            throw new Error('Use "Telemetry.setup()" to instantiate telemetry client.');
        }
        return this._instance;
    }
    static setup(key, packageName, packageVersion, tracesSampleRate, defaults) {
        this._instance = new Telemetry(key, {
            release: packageVersion,
            environment: packageVersion.includes('-') ? 'insiders' : 'production',
            tracesSampleRate,
        }, {
            ...defaults,
            packageName,
        });
    }
    static extend(defaults) {
        Object.assign(this.instance.defaults, defaults);
    }
    static optOut() {
        if (this._instance != null) {
            this._instance.optOut = true;
        }
    }
}
async function tracePromise(event, promise) {
    const done = trace(event);
    try {
        return await promise;
    }
    catch (error) {
        collectError(error);
        throw error;
    }
    finally {
        done();
    }
}
function trace(event, description) {
    return Telemetry.instance.trace(event, description);
}
function collectError(error) {
    return Telemetry.instance.error(error);
}
function collect(key, value) {
    return Telemetry.instance.collect(key, value);
}

export { Telemetry, camelCase, camelize, capitalize, collect, collectError, concat, findNextSibling, findPrevSibling, first, getComponentName, getComponentNameAliases, getRelativeFileName, hyphenate, isArray, isCamelCase, isKebabCase, isNotNull, isNumber, isPascalCase, isString, kebabCase, last, pascalCase, trace, tracePromise, uncapitalize };
//# sourceMappingURL=index.esm.js.map
