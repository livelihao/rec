import { collectError, collect, Telemetry } from '@vuedx/shared';
import glob from 'fast-glob';
import Path from 'path';
import FS, { promises } from 'fs';
import TS from 'typescript/lib/tsserverlibrary';
import { fork } from 'child_process';
import readline, { createInterface } from 'readline';
import resolveFrom from 'resolve-from';
import chalk from 'chalk';
import parseArgs from 'minimist';

var version = "0.6.0";

function resolve(moduleId, directory) {
    try {
        return resolveFrom(directory, moduleId);
    }
    catch (_a) {
        return require.resolve(moduleId);
    }
}
const isDebugMode = process.env.DEBUG != null;
function debug(...args) {
}
class TypeScriptServerHost {
    constructor() {
        var _a;
        this.voidCommands = [
            "open" /* Open */,
            "geterr" /* Geterr */,
            "geterrForProject" /* GeterrForProject */,
        ];
        this.serverPath = resolve('typescript/lib/tsserver', process.cwd());
        this.pluginPath = Path.dirname(require.resolve('@vuedx/typescript-plugin-vue/package.json'));
        this.isClosed = false;
        this.pendingResponses = 0;
        this.responseHandlers = new Map();
        this._messageId = 0;
        this.eventHandlers = {};
        // prettier-ignore
        const debugArgs = process.env.DEBUG_TS_SERVER != null
            ? [
                '--logVerbosity', 'verbose',
                '--logFile',
                (_a = process.env.TS_SERVER_LOG_FILE) !== null && _a !== void 0 ? _a : 'tsserver.log',
            ]
            : [];
        // prettier-ignore
        this.server = fork(this.serverPath, [
            ...debugArgs,
            '--globalPlugins', this.pluginPath,
            '--pluginProbeLocations', this.pluginPath,
            '--allowLocalPluginLoads',
            '--useSingleInferredProject'
        ], {
            cwd: process.cwd(),
            stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
            execArgv: process.env.TS_SERVER_INSPECT != null ? ['--inspect'] :
                process.env.TS_SERVER_INSPECT_BRK != null ? ['--inspect-brk=9229'] :
                    []
        });
        this.exitStatus = new Promise((resolve) => {
            let isResolved = false;
            this.server.on('exit', (code) => {
                if (!isResolved)
                    resolve(code !== null && code !== void 0 ? code : 0);
            });
            this.server.on('error', (error) => {
                isResolved = true;
                console.error(error);
                resolve(-1);
            });
        });
        if (this.server.stdout == null)
            throw new Error('No stdout');
        if (this.server.stdin == null)
            throw new Error('No stdin');
        this.stdout = this.server.stdout;
        this.stdin = this.server.stdin;
        this.stdout.setEncoding('utf-8');
        this.readline = createInterface({ input: this.stdout });
        this.readline.on('line', (line) => {
            var _a;
            if (line.startsWith('{')) {
                const payload = JSON.parse(line);
                if (payload.type === 'response') {
                    this.pendingResponses -= 1;
                    (_a = this.responseHandlers.get(payload.request_seq)) === null || _a === void 0 ? void 0 : _a(payload);
                }
                else if (payload.type === 'request') ;
                else if (payload.type === 'event') {
                    this.onEvent(payload);
                }
                if (this.isClosed) {
                    this.shutdown();
                }
            }
        });
    }
    getNextMessageId() {
        return this._messageId++;
    }
    onEvent(payload) {
        var _a;
        (_a = this.eventHandlers[payload.event]) === null || _a === void 0 ? void 0 : _a.forEach((fn) => fn(payload.body));
    }
    send(message) {
        if (this.isClosed) {
            throw new Error('Cannot send messages to a closed server connection.');
        }
        const seq = this.getNextMessageId();
        const payload = { seq, ...message };
        this.stdin.write(JSON.stringify(payload) + '\n');
        return seq;
    }
    on(event, fn) {
        var _a;
        const handlers = (_a = this.eventHandlers[event]) !== null && _a !== void 0 ? _a : (this.eventHandlers[event] = []);
        handlers.push(fn);
        return () => {
            const index = handlers.indexOf(fn);
            if (index >= 0) {
                handlers.splice(index, 1);
            }
        };
    }
    async sendRequest(request) {
        const id = this.send({ type: 'request', ...request });
        if (!this.voidCommands.includes(request.command)) {
            this.pendingResponses += 1;
            return await new Promise((resolve) => {
                this.responseHandlers.set(id, (response) => resolve(response));
            });
        }
        else {
            return id;
        }
    }
    sendEvent(event) {
        this.send({ type: 'event', ...event });
    }
    async close() {
        this.isClosed = true;
        this.shutdown();
        return await this.exitStatus;
    }
    shutdown() {
        if (this.pendingResponses <= 0) {
            this.stdin.end();
        }
        else {
            debug(`shutting after ${this.pendingResponses}...`);
        }
    }
    async sendCommand(command, args) {
        return this.sendRequest({ command, arguments: args });
    }
}

function toNormalizedPath(fileName) {
    return TS.server.toNormalizedPath(fileName);
}
class AbortSignal {
    constructor() {
        this._aborted = false;
    }
    get aborted() {
        return this._aborted;
    }
    // eslint-disable-next-line accessor-pairs
    set onabort(fn) {
        this._onabort = fn;
    }
    async dispatchEvent(event) {
        var _a;
        this._aborted = true;
        return await ((_a = this._onabort) === null || _a === void 0 ? void 0 : _a.call(this));
    }
}
class AbortController {
    constructor() {
        this.signal = new AbortSignal();
    }
    async abort() {
        // @ts-expect-error
        return await this.signal.dispatchEvent('aborted');
    }
}
async function* getDiagnostics(directory, cancellationToken, logging = false) {
    var _a, _b;
    const host = new TypeScriptServerHost();
    cancellationToken.onabort = async () => {
        await host.close();
    };
    const projectRootPath = toNormalizedPath(directory);
    const diagnosticsPerFile = new Map();
    function setDiagnostics(fileName, kind, diagnostics) {
        var _a;
        if (fileName.includes('/node_modules/'))
            return;
        if (diagnostics.length > 0) {
            const current = (_a = diagnosticsPerFile.get(fileName)) !== null && _a !== void 0 ? _a : {};
            diagnosticsPerFile.set(fileName, {
                ...current,
                [kind]: diagnostics,
            });
        }
    }
    const pack = () => Array.from(diagnosticsPerFile.entries())
        .map(([fileName, diagnostics]) => ({
        fileName,
        diagnostics: merge(diagnostics.semantic, diagnostics.suggestion, diagnostics.syntax),
    }))
        .filter((item) => item.diagnostics.length > 0);
    let useProject = true;
    const refresh = async (files) => {
        diagnosticsPerFile.clear();
        const start = Date.now();
        if (logging)
            console.log(`Checking...`);
        const id = useProject
            ? await host.sendCommand('geterrForProject', { file: files[0], delay: 1 })
            : await host.sendCommand('geterr', { files, delay: 1 });
        return await new Promise((resolve) => {
            const off = host.on('requestCompleted', async (event) => {
                if (event.request_seq === id) {
                    if (logging) {
                        console.log(`Completed in ${((Date.now() - start) / 1000).toFixed(2)}s`);
                    }
                    resolve(pack());
                    off();
                }
            });
        });
    };
    await host.sendCommand('configure', {
        hostInfo: '@vuedx/typecheck',
        preferences: { disableSuggestions: false },
    });
    let files;
    const jsConfig = Path.resolve(directory, 'jsconfig.json');
    const tsConfig = Path.resolve(directory, 'tsconfig.json');
    if (FS.existsSync(tsConfig) || FS.existsSync(jsConfig)) {
        useProject = true;
        const configFile = FS.existsSync(tsConfig) ? tsConfig : jsConfig;
        await host.sendCommand('updateOpen', {
            openFiles: [
                {
                    file: toNormalizedPath(configFile),
                    projectRootPath,
                },
            ],
        });
        const { body } = await host.sendCommand('projectInfo', {
            file: toNormalizedPath(configFile),
            projectFileName: toNormalizedPath(configFile),
            needFileNameList: true,
        });
        files = (_b = (_a = body === null || body === void 0 ? void 0 : body.fileNames) === null || _a === void 0 ? void 0 : _a.filter((fileName) => !fileName.includes('/node_modules/') && !fileName.endsWith('.json'))) !== null && _b !== void 0 ? _b : [];
        if (files.length > 0) {
            await host.sendCommand('updateOpen', {
                closedFiles: [toNormalizedPath(configFile)],
            });
            await host.sendCommand('updateOpen', {
                openFiles: [
                    {
                        file: toNormalizedPath(files[0]),
                        projectFileName: toNormalizedPath(configFile),
                    },
                ],
            });
        }
    }
    else {
        await host.sendCommand('compilerOptionsForInferredProjects', {
            options: {
                allowJs: true,
                checkJs: true,
                strict: true,
                alwaysStrict: true,
                allowNonTsExtensions: true,
                jsx: 'preserve',
            },
        });
        files = (await glob(['**/*.vue', '**/*.ts', '**/*.js', '**/*.jsx', '**/*.tsx'], {
            cwd: directory,
            absolute: true,
            ignore: ['node_modules', 'dist'],
        })).map((fileName) => toNormalizedPath(fileName));
        await host.sendCommand('updateOpen', {
            openFiles: files.map((file) => ({ file, projectRootPath })),
        });
    }
    let done;
    let promise = new Promise((resolve) => {
        done = resolve;
        void refresh(files).then(done);
    });
    const next = () => {
        promise = new Promise((resolve) => {
            done = resolve;
        });
    };
    host.on('projectsUpdatedInBackground', async (event) => {
        done(await refresh(files));
    });
    host.on('semanticDiag', (event) => {
        setDiagnostics(event.file, 'semantic', event.diagnostics);
    });
    host.on('syntaxDiag', (event) => {
        setDiagnostics(event.file, 'syntax', event.diagnostics);
    });
    host.on('suggestionDiag', (event) => {
        setDiagnostics(event.file, 'suggestion', event.diagnostics);
    });
    while (!cancellationToken.aborted) {
        yield await promise;
        next();
    }
    return pack();
}
async function getDiagnostics2(directory) {
    const controller = new AbortController();
    const stream = getDiagnostics(directory, controller.signal);
    const result = await stream.next();
    await controller.abort();
    return result.value;
}
function merge(...items) {
    return items.flatMap((item) => item !== null && item !== void 0 ? item : []);
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (changes, version) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                var range = getWellformedRange(change.range);
                // update content
                var startOffset = this.offsetAt(range.start);
                var endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                var startLine = Math.max(range.start.line, 0);
                var endLine = Math.max(range.end.line, 0);
                var lineOffsets = this._lineOffsets;
                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                var diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return { line: line, character: offset - lineOffsets[line] };
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.isIncremental = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    };
    FullTextDocument.isFull = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    };
    return FullTextDocument;
}());
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifing its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = 0;
        var spans = [];
        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
            var e = sortedEdits_1[_i];
            var startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            }
            else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    var p = (data.length / 2) | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
    if (textOffset === void 0) { textOffset = 0; }
    var result = isAtLineStart ? [textOffset] : [];
    for (var i = 0; i < text.length; i++) {
        var ch = text.charCodeAt(i);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function getWellformedRange(range) {
    var start = range.start;
    var end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    var range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range: range };
    }
    return textEdit;
}

function generateCodeFrame(source, start = 0, end = source.length, underline = (str) => str, gutter = (str) => str, range = 2) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    const width = String(lines.length).length;
    const getLine = (line) => String(line).padStart(width) + ' | ';
    for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${gutter(getLine(line))}${lines[j]}`);
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(gutter(getLine('')) +
                        ' '.repeat(pad) +
                        underline('~'.repeat(length)));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(gutter(getLine('')) + underline('~'.repeat(length)));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

const colors = {
    warning: chalk.yellow,
    error: chalk.red,
    suggestion: chalk.green,
    message: chalk.blueBright,
};
let directory = process.cwd();
const cache = new Map();
function print(chunk) {
    process.stdout.write(chunk);
}
async function getTextDocument(file) {
    var _a;
    return (_a = cache.get(file)) !== null && _a !== void 0 ? _a : (await createTextDocument(file));
}
function clearScreen() {
    const blank = '\n'.repeat(process.stdout.rows);
    console.log(blank);
    readline.cursorTo(process.stdout, 0, 0);
    readline.clearScreenDown(process.stdout);
}
async function createTextDocument(file) {
    const content = await promises.readFile(file, { encoding: 'utf-8' });
    const fileName = toNormalizedPath$1(file);
    const document = TextDocument.create(fileName, Path.posix.extname(file), 0, content);
    cache.set(fileName, document);
    return document;
}
function toNormalizedPath$1(fileName) {
    return TS.server.toNormalizedPath(fileName);
}
function formatLocation(fileName, start) {
    const relativeFileName = convertToRelativePath(fileName);
    const line = start.line + 1;
    const column = start.offset + 1;
    let output = '';
    output += chalk.cyan(relativeFileName);
    output += ':';
    output += chalk.yellow(`${line}`);
    output += ':';
    output += chalk.yellow(`${column}`);
    return output;
}
function getDiagnosticCategory(diagnostic) {
    return (/^(warning|error|suggestion|message)$/i.test(diagnostic.category)
        ? diagnostic.category.toLowerCase()
        : 'error');
}
function toPosition(loc) {
    return { line: loc.line - 1, character: loc.offset - 1 };
}
async function formatDiagnosticsWithColorAndContext(fileName, diagnostic) {
    var _a, _b;
    let output = '';
    output += formatLocation(fileName, diagnostic.start); // TODO: GH#18217
    output += ' - ';
    const category = getDiagnosticCategory(diagnostic);
    output += colors[category](category);
    output += chalk.gray(` ${(_a = diagnostic.source) !== null && _a !== void 0 ? _a : ''}${(_b = diagnostic.code) !== null && _b !== void 0 ? _b : ''}: `);
    output += diagnostic.text;
    const document = await getTextDocument(fileName);
    output += '\n';
    output += generateCodeFrame(document.getText(), document.offsetAt(toPosition(diagnostic.start)), document.offsetAt(toPosition(diagnostic.end)), (underline) => colors[category](underline), (gutter) => chalk.bgWhite(gutter.trimEnd()) + ' ');
    if (diagnostic.relatedInformation != null) {
        for (const { message, span, category } of diagnostic.relatedInformation) {
            output += '\n';
            const color = colors[getDiagnosticCategory({ category })];
            if (span != null) {
                output += '    ' + formatLocation(span.file, span.start);
                const document = await getTextDocument(span.file);
                output += '\n';
                output += generateCodeFrame(document.getText(), document.offsetAt(toPosition(span.start)), document.offsetAt(toPosition(span.end)), (underline) => color(underline), (gutter) => chalk.bgWhite(gutter.trimEnd()) + ' ');
                output += '\n';
            }
            output += '    ' + message;
        }
    }
    output += '\n';
    return output;
}
function formatDiagnostic(fileName, diagnostic) {
    var _a, _b;
    const errorMessage = `${diagnostic.category} ${(_a = diagnostic.source) !== null && _a !== void 0 ? _a : ''}${(_b = diagnostic.code) !== null && _b !== void 0 ? _b : ''}: ${diagnostic.text}`;
    const relativeFileName = convertToRelativePath(fileName);
    const line = diagnostic.start.line + 1;
    const column = diagnostic.start.offset + 1;
    return `${relativeFileName}(${line},${column}): ${errorMessage}`;
}
const ERROR_RE = /^(error)$/i;
function getErrorCount(diagnostics) {
    return diagnostics.reduce((count, diagnostic) => count +
        diagnostic.diagnostics.filter((diagnostic) => ERROR_RE.test(diagnostic.category)).length, 0);
}
function convertToRelativePath(fileName) {
    return Path.isAbsolute(fileName)
        ? Path.relative(directory, fileName).replace(/\\/g, '/')
        : fileName;
}
async function _cli() {
    const { pretty, vue, help, watch, format, _: argv } = parseArgs(process.argv.slice(2), {
        boolean: ['json', 'rdjson', 'verbose', 'vue', 'help', 'pretty', 'watch'],
        string: ['format'],
        default: { pretty: true, format: 'raw' },
    });
    if (help === true) {
        console.error(`
Usage: vuedx-typecheck [directory] <options>

Options
    --format    One of 'raw', 'json' or 'rdjson'
    --vue       process only vue files
    --no-pretty Pretty print output
    --help      display help
    --watch     Watch files for changes
`.trim());
        process.exit(0);
    }
    directory =
        argv[0] != null
            ? Path.isAbsolute(argv[0])
                ? argv[0]
                : Path.resolve(process.cwd(), argv[0])
            : process.cwd();
    if (!FS.existsSync(directory)) {
        console.error(`Cannot find directory: "${String(argv[0])}"`);
        process.exit(1);
    }
    console.debug('Running for ' + directory);
    if (!FS.statSync(directory).isDirectory()) {
        console.error(`Expecting a directory, but "${process.argv[2]}" is not a directory.`);
        process.exit(1);
    }
    collect('cli exec', {
        watch,
        format,
        vue,
        pretty,
    });
    if (watch === true) {
        const controller = new AbortController();
        for await (const result of getDiagnostics(directory, controller.signal, true)) {
            clearScreen();
            await handleResults(result, { format, pretty, vue });
        }
    }
    else {
        const result = await getDiagnostics2(directory);
        await handleResults(result, { format, pretty, vue });
        if (getErrorCount(result) > 0 && format === 'raw')
            process.exit(2);
        else
            process.exit(0);
    }
}
async function cli() {
    try {
        await _cli();
    }
    catch (error) {
        collectError(error);
        throw error;
    }
}
/**
 * Return diagnostic result in Reviewdog Diagnostic Format
 * @see https://github.com/reviewdog/reviewdog/tree/master/proto/rdf#rdjson
 */
function encodeRdJSON(result, pretty) {
    const severityMap = {
        warning: 'WARNING',
        error: 'ERROR',
        suggestion: 'INFO',
        message: 'INFO',
    };
    return JSON.stringify({
        source: {
            name: 'VueDX typecheck',
            url: 'https://github.com/znck/vue-developer-experience/tree/master/packages/typecheck',
        },
        diagnostics: result.flatMap((sourceFile) => {
            return sourceFile.diagnostics.map((diagnostic) => {
                var _a, _b;
                return ({
                    message: diagnostic.text,
                    severity: severityMap[diagnostic.category],
                    location: {
                        path: sourceFile.fileName,
                        range: {
                            start: {
                                line: diagnostic.start.line,
                                column: diagnostic.start.offset,
                            },
                            end: { line: diagnostic.end.line, column: diagnostic.end.offset },
                        },
                    },
                    code: {
                        value: `${(_a = diagnostic.code) !== null && _a !== void 0 ? _a : ''}`,
                    },
                    relatedInformation: (_b = diagnostic.relatedInformation) === null || _b === void 0 ? void 0 : _b.map((info) => {
                        var _a;
                        return ({
                            message: info.message,
                            severity: severityMap[info.category],
                            location: info.span != null
                                ? {
                                    path: info.span.file,
                                    range: {
                                        start: {
                                            line: info.span.start.line,
                                            column: info.span.start.offset,
                                        },
                                        end: {
                                            line: info.span.end.line,
                                            column: info.span.end.offset,
                                        },
                                    },
                                }
                                : undefined,
                            code: {
                                value: `${(_a = info.code) !== null && _a !== void 0 ? _a : ''}`,
                            },
                        });
                    }),
                });
            });
        }),
    }, null, pretty ? 2 : 0);
}
async function handleResults(result, { vue, format, pretty, }) {
    if (vue) {
        result = result.filter((item) => item.fileName.endsWith('.vue'));
    }
    result.forEach((sourceFile) => {
        sourceFile.fileName = convertToRelativePath(sourceFile.fileName);
        sourceFile.diagnostics.forEach((diagnostic) => {
            var _a;
            (_a = diagnostic.relatedInformation) === null || _a === void 0 ? void 0 : _a.forEach((info) => {
                if (info.span != null) {
                    info.span.file = convertToRelativePath(info.span.file);
                }
            });
        });
    });
    switch (format) {
        case 'json':
            print(JSON.stringify(result, null, pretty ? 2 : 0));
            break;
        case 'rdjson':
            print(encodeRdJSON(result, pretty));
            break;
        case 'raw':
            {
                const fn = pretty
                    ? formatDiagnosticsWithColorAndContext
                    : formatDiagnostic;
                const content = await Promise.all(result.flatMap((sourceFile) => sourceFile.diagnostics.map((diagnostic) => fn(sourceFile.fileName, diagnostic))));
                print(content.join('\n'));
                const count = getErrorCount(result);
                print(`\nFound ${count} ${count === 1 ? 'error' : 'errors'}.`);
            }
            break;
        default:
            throw new Error(`Unknown output format: "${format}"`);
    }
}

async function cli$1() {
    setup();
    return await cli();
}
async function getDiagnostics$1(directory) {
    setup();
    try {
        return await getDiagnostics2(directory);
    }
    catch (error) {
        collectError(error);
        return error;
    }
}
function setup() {
    Telemetry.setup('https://212f65f46796440ebbe974f24b20ffae@o237831.ingest.sentry.io/5595698', 'typecheck', version, process.env.CI != null ? 1 : 0.25, {
        ci: process.env.CI,
    });
}

export { cli$1 as cli, getDiagnostics$1 as getDiagnostics };
//# sourceMappingURL=index.esm.js.map
