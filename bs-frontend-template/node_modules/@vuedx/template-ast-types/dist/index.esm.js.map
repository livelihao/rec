{"version":3,"file":"index.esm.js","sources":["../src/assert.ts","../src/create.ts","../src/traverse.ts","../src/helpers.ts","../src/stringify.ts"],"sourcesContent":["import {\n  AttributeNode,\n  CommentNode,\n  ComponentNode,\n  DirectiveNode,\n  ElementNode,\n  InterpolationNode,\n  isSimpleIdentifier as _isSimpleIdentifier,\n  Node,\n  PlainElementNode,\n  RootNode,\n  SimpleExpressionNode,\n  TemplateNode,\n  TextNode,\n} from '@vue/compiler-core'\n\n/**\n * Checks if it is a valid JavaScript identifers.\n *\n * @public\n */\nexport function isSimpleIdentifier(content: string): boolean {\n  return _isSimpleIdentifier(content.trim())\n}\n\n/**\n * Checks if it is Vue template AST Node.\n *\n * @public\n */\nexport function isNode(node: unknown): node is Node {\n  return typeof node === 'object' && node != null && 'type' in node\n}\n\n/**\n * Checks if it is an AST RootNode.\n *\n * @public\n */\nexport function isRootNode(node: unknown): node is RootNode {\n  return isNode(node) && node.type === 0\n}\n\n/**\n * Checks if it is an AST ElementNode.\n *\n * @public\n */\nexport function isElementNode(node: unknown): node is ElementNode {\n  return isNode(node) && node.type === 1\n}\n\n/**\n * Checks if it is an AST PlainElementNode.\n *\n * @public\n */\nexport function isPlainElementNode(node: unknown): node is PlainElementNode {\n  return isElementNode(node) && node.tagType === 0\n}\n\n/**\n * Checks if it is an AST ComponentNode.\n *\n * @public\n */\nexport function isComponentNode(node: unknown): node is ComponentNode {\n  return isElementNode(node) && node.tagType === 1\n}\n\n/**\n * Checks if it is an AST TemplateNode.\n * @public\n */\nexport function isTemplateNode(node: unknown): node is TemplateNode {\n  return isElementNode(node) && node.tagType === 3\n}\n\n/**\n * Checks if it is an AST TextNode.\n * @public\n */\nexport function isTextNode(node: unknown): node is TextNode {\n  return isNode(node) && node.type === 2\n}\n\n/**\n * Checks if it is an AST CommentNode.\n * @public\n */\nexport function isCommentNode(node: unknown): node is CommentNode {\n  return isNode(node) && node.type === 3\n}\n\n/**\n * Checks if it is an AST ExpressionNode.\n * @public\n */\nexport function isSimpleExpressionNode(\n  node: unknown,\n): node is SimpleExpressionNode {\n  return isNode(node) && node.type === 4\n}\n\n/**\n * Checks if it is an AST InterpolationNode.\n * @public\n */\nexport function isInterpolationNode(node: unknown): node is InterpolationNode {\n  return isNode(node) && node.type === 5\n}\n\n/**\n * Checks if it is an AST AttributeNode.\n * @public\n */\nexport function isAttributeNode(node: unknown): node is AttributeNode {\n  return isNode(node) && node.type === 6\n}\n\n/**\n * Checks if it is an AST DirectiveNode.\n * @public\n */\nexport function isDirectiveNode(node: unknown): node is DirectiveNode {\n  return isNode(node) && node.type === 7\n}\n","import {\n  SimpleExpressionNode,\n  createSimpleExpression as _createSimpleExpression,\n  SourceLocation,\n} from '@vue/compiler-core'\n\n/**\n * Create AST Node\n *\n * @public\n */\nexport function createSimpleExpression(\n  content: SimpleExpressionNode['content'],\n  isStatic: SimpleExpressionNode['isStatic'],\n  loc?: SourceLocation,\n  isConstant?: boolean,\n): SimpleExpressionNode {\n  return _createSimpleExpression(content, isStatic, loc, isConstant)\n}\n","import { Node } from '@vue/compiler-core'\nimport { isNode } from './assert'\n\nconst VISITOR_KEYS = ([\n  ['children'], // ROOT = 0,\n  ['props', 'children'], // ELEMENT = 1,\n  [], // TEXT = 2,\n  [], // COMMENT = 3,\n  [], // SIMPLE_EXPRESSION = 4,\n  ['content'], // INTERPOLATION = 5,\n  ['value'], // ATTRIBUTE = 6,\n  ['exp', 'arg'], // DIRECTIVE = 7,\n] as unknown) as Record<Node['type'], Array<keyof Node>>\n\n/**\n * @public\n */\nexport type TraversalAncestors = Array<{\n  node: Node\n  key: string\n  index?: number\n}>\n\n/**\n * @public\n */\nexport type TraversalHandler<T> = (\n  node: Node,\n  ancestors: TraversalAncestors,\n  state: T,\n) => void\n\n/**\n * @public\n */\nexport interface TraversalHandlers<T> {\n  enter?: TraversalHandler<T>\n  exit?: TraversalHandler<T>\n}\n\n/**\n * A general AST traversal utility with both prefix and postfix handlers, and a\n * state object. Exposes ancestry data to each handler so that more complex\n * AST data can be taken into account.\n *\n * @public\n */\nexport function traverse<T>(\n  node: Node,\n  handlers: TraversalHandler<T> | TraversalHandlers<T>,\n  state?: T,\n): void {\n  if (typeof handlers === 'function') {\n    handlers = { enter: handlers }\n  }\n\n  const { enter, exit } = handlers\n\n  traverseSimpleImpl(node, enter, exit, state, [])\n}\n\nfunction traverseSimpleImpl<T>(\n  node: Object,\n  enter: Function | undefined,\n  exit: Function | undefined,\n  state: T,\n  ancestors: TraversalAncestors,\n): void {\n  if (!isNode(node)) return\n\n  const keys = VISITOR_KEYS[node.type]\n  if (keys == null) return\n\n  if (enter != null) enter(node, ancestors, state)\n\n  for (const key of keys) {\n    const subNode = node[key]\n\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i]\n        if (child == null) continue\n\n        ancestors.push({\n          node,\n          key,\n          index: i,\n        })\n\n        traverseSimpleImpl(child, enter, exit, state, ancestors)\n\n        ancestors.pop()\n      }\n    } else if (subNode != null) {\n      ancestors.push({\n        node,\n        key,\n      })\n\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors)\n\n      ancestors.pop()\n    }\n  }\n\n  if (exit != null) exit(node, ancestors, state)\n}\n\n/**\n * An abortable AST traversal utility. Return false (or falsy value) to stop traversal.\n *\n * @public\n */\nexport function traverseEvery<T>(\n  node: Node,\n  enter: (node: Node, ancestors: TraversalAncestors, state: T) => boolean,\n  state?: any,\n  ancestors: TraversalAncestors = [],\n): void {\n  if (!isNode(node)) return\n  const keys = VISITOR_KEYS[node.type]\n  if (keys == null) return\n\n  if (enter(node, ancestors, state)) {\n    for (const key of keys) {\n      const subNode = node[key]\n      if (Array.isArray(subNode)) {\n        for (let i = 0; i < subNode.length; i++) {\n          const child = subNode[i]\n          if (isNode(child)) {\n            ancestors.push({\n              node,\n              key,\n              index: i,\n            })\n            traverseEvery(child, enter, state, ancestors)\n            ancestors.pop()\n          }\n        }\n      } else if (isNode(subNode)) {\n        ancestors.push({\n          node,\n          key,\n        })\n        traverseEvery(subNode, enter, state, ancestors)\n        ancestors.pop()\n      }\n    }\n  }\n}\n\n/**\n * A faster AST traversal utility. It behaves same as [traverse()] but there is no ancestory data.\n *\n * @public\n */\nexport function traverseFast<T = any>(\n  node: object,\n  enter: (node: Node, state: T, stop: () => void) => void,\n  state?: T,\n): void {\n  if (!isNode(node)) return\n\n  const keys = VISITOR_KEYS[node.type]\n  if (keys == null) return\n\n  let isStopped = false\n  const stop = (): void => {\n    isStopped = true\n  }\n  enter(node, state as T, stop)\n  if (isStopped) return\n\n  const forwardEnter = (node: Node, state: T, prevStop: () => void): void => {\n    enter(node, state, () => {\n      stop()\n      prevStop()\n    })\n  }\n  for (const key of keys) {\n    const subNode = node[key]\n\n    if (Array.isArray(subNode)) {\n      for (const node of subNode) {\n        traverseFast(node, forwardEnter, state)\n        if (isStopped) return\n      }\n    } else if (isNode(subNode)) {\n      traverseFast(subNode, forwardEnter, state)\n      if (isStopped) return\n    }\n  }\n}\n","import { ElementNode, Node, RootNode } from '@vue/compiler-core'\nimport {\n  isCommentNode,\n  isElementNode,\n  isInterpolationNode,\n  isRootNode,\n  isTextNode,\n} from './assert'\nimport { TraversalAncestors, traverseEvery, traverseFast } from './traverse'\n\n/**\n * @public\n */\nexport interface SearchResult {\n  node: Node | null\n  ancestors: TraversalAncestors\n}\n\n/**\n * Find the deepest node containing the given position.\n *\n * @public\n */\nexport function findTemplateNodeAt(\n  ast: RootNode,\n  position: number,\n): SearchResult {\n  return findTemplateNodeInRange(ast, position, position)\n}\n\n/**\n * Find the parent element node.\n *\n * @public\n */\nexport function findParentNode(\n  ast: RootNode,\n  node: Node,\n): ElementNode | undefined {\n  let result: ElementNode | undefined\n  traverseEvery(ast, (element) => {\n    if (isElementNode(element)) {\n      if (element.children.includes(node as any)) {\n        result = element\n\n        return false\n      }\n    }\n\n    return true\n  })\n\n  return result\n}\n\n/**\n * Find a child (element, component, text, interpolation, or comment) node containing the given position.\n *\n * @public\n * @param mode - Open/close range comparison mode:\n *  • undefined - position in [start, end]\n *  • 'start'   — position in [start, end)\n *  • 'end'     - position in (start, end]\n */\nexport function findTemplateChildNodeAt(\n  ast: RootNode,\n  position: number,\n  mode?: 'start' | 'end',\n): SearchResult {\n  const result = findTemplateNodeInRange(ast, position, position, mode)\n\n  while (result.ancestors.length > 0) {\n    if (\n      isRootNode(result.node) ||\n      isElementNode(result.node) ||\n      isTextNode(result.node) ||\n      isInterpolationNode(result.node) ||\n      isCommentNode(result.node)\n    ) {\n      break\n    }\n\n    result.node = result.ancestors.pop()?.node ?? null\n  }\n\n  return (result as unknown) as {\n    node: ElementNode | null\n    ancestors: TraversalAncestors\n  }\n}\n\n/**\n * Find the deepest node containing the given position.\n *\n * @public\n * @param mode - Open/close range comparison mode:\n *  • undefined - position in [start, end]\n *  • 'start'   — position in [start, end)\n *  • 'end'     - position in (start, end]\n */\nexport function findTemplateNodeInRange(\n  ast: RootNode,\n  start: number,\n  end: number,\n  mode?: 'start' | 'end',\n): SearchResult {\n  const found = {\n    node: null as Node | null,\n    ancestors: [] as TraversalAncestors,\n  }\n\n  traverseEvery(ast, (node, ancestors) => {\n    if (\n      mode === 'start'\n        ? node.loc.start.offset <= start && end < node.loc.end.offset\n        : mode === 'end'\n        ? node.loc.start.offset < start && end <= node.loc.end.offset\n        : node.loc.start.offset <= start && end <= node.loc.end.offset\n    ) {\n      found.node = node\n      found.ancestors = ancestors.slice()\n\n      return true\n    } else {\n      return false\n    }\n  })\n\n  return found\n}\n\n/**\n * Get all nodes contained in given range. (partial overlaps are ignored)\n *\n * @public\n */\nexport function findTemplateNodesInRange(\n  ast: RootNode,\n  start: number,\n  end: number,\n): Node[] {\n  const found: Node[] = []\n\n  traverseFast(ast, (node) => {\n    if (node.loc.start.offset <= start && end <= node.loc.end.offset) {\n      found.push(node)\n    }\n  })\n\n  return found\n}\n\n/**\n * Get all child (element, component, text, interpolation, or comment) nodes contained in given range. (partial overlaps are ignored)\n *\n * @public\n */\nexport function findTemplateChildrenInRange(\n  ast: RootNode,\n  start: number,\n  end: number,\n): Node[] {\n  if (start === end) {\n    const a = findTemplateChildNodeAt(ast, start)\n\n    return a.node != null ? [a.node] : []\n  }\n\n  const a = findTemplateChildNodeAt(ast, start, 'start')\n  const b = findTemplateChildNodeAt(ast, end, 'end')\n  if (a.node == null || b.node == null) return []\n  if (a.node === b.node) return [a.node]\n\n  const pa = a.ancestors.pop()?.node\n  const pb = b.ancestors.pop()?.node\n\n  if (pa == null || pb == null) return []\n\n  if (pa === b.node) return [pa]\n  if (pb === a.node) return [pb]\n\n  if (pa === pb && isElementNode(pa)) {\n    return pa.children.slice(\n      pa.children.indexOf(a.node as any),\n      1 + pa.children.indexOf(b.node as any),\n    )\n  }\n\n  return []\n}\n","import type {\n  AttributeNode,\n  DirectiveNode,\n  ElementNode,\n  Node,\n  RootNode,\n  SimpleExpressionNode,\n  TextNode,\n} from '@vue/compiler-core'\nimport {\n  isAttributeNode,\n  isDirectiveNode,\n  isElementNode,\n  isInterpolationNode,\n  isRootNode,\n  isSimpleExpressionNode,\n  isTextNode,\n} from './assert'\n\n/**\n * @public\n */\nexport interface StringifyOptions {\n  indent: number\n  initialIndent: number\n  directive: 'shorthand' | 'longhand'\n  replaceNodes: Map<Node, Node | null>\n}\n\nconst defaults: StringifyOptions = {\n  indent: 2,\n  initialIndent: 0,\n  directive: 'shorthand',\n  replaceNodes: new Map<Node, Node | null>(),\n}\n\n/**\n * Convert template AST to template code.\n *\n * @public\n */\nexport function stringify(\n  node: Node | Node[],\n  options?: Partial<StringifyOptions>,\n): string {\n  const finalOptions = { ...defaults, ...options }\n\n  return genNode(\n    Array.isArray(node) ? ({ type: 0, children: node } as any) : node,\n    finalOptions.initialIndent * finalOptions.initialIndent,\n    finalOptions,\n  )\n}\n\nconst shorthands = {\n  bind: ':',\n  on: '@',\n  slot: '#',\n} as const\n\nfunction genNode(\n  node: Node,\n  indent: number,\n  options: StringifyOptions,\n): string {\n  if (options.replaceNodes.has(node)) {\n    const replaced = options.replaceNodes.get(node)\n    return replaced == null ? '' : genNode(replaced, indent, options)\n  } else if (isRootNode(node)) {\n    return genRootNode(node, indent, options)\n  } else if (isElementNode(node)) {\n    return genElementNode(node, indent, options)\n  } else if (isAttributeNode(node)) {\n    return genAttributeNode(node, indent, options)\n  } else if (isDirectiveNode(node)) {\n    return genDirectiveNode(node, indent, options)\n  } else if (isInterpolationNode(node)) {\n    return `{{ ${genNode(node.content, indent, options)} }}`\n  } else if (isSimpleExpressionNode(node)) {\n    return genExpressionNode(node, indent, options)\n  } else if (isTextNode(node)) {\n    return genTextNode(node, indent, options)\n  } else {\n    throw new Error(`Unsupported node type: ${node.type}`)\n  }\n}\n\nfunction genExpressionNode(\n  node: SimpleExpressionNode,\n  indent: number,\n  options: StringifyOptions,\n): string {\n  return genMultilineText(node.content, indent, options)\n}\n\nfunction genTextNode(\n  node: TextNode,\n  indent: number,\n  options: StringifyOptions,\n): string {\n  return genMultilineText(node.content, indent, options)\n}\n\nfunction genMultilineText(\n  content: string,\n  indent: number,\n  options: StringifyOptions,\n): string {\n  if (content.startsWith('\\n')) {\n    content = content.trimStart()\n  }\n\n  if (content.includes('\\n')) {\n    content = content\n      .split('\\n')\n      .map((line) => line.trim())\n      .join('\\n' + ' '.repeat(indent + options.indent))\n  }\n\n  return content\n}\n\nfunction genRootNode(\n  node: RootNode,\n  indent: number,\n  options: StringifyOptions,\n): string {\n  return genChildren(node, indent, options)\n}\n\nfunction genElementNode(\n  node: ElementNode,\n  indent: number,\n  options: StringifyOptions,\n): string {\n  const code: string[] = []\n\n  code.push(' '.repeat(indent), '<', node.tag)\n\n  let shouldIndentClosing = false\n  const props = applyReplaceNodes(node.props, options)\n  if (props.length > 0) {\n    if (props.length > 2) {\n      code.push('\\n')\n      node.props.forEach((prop) => {\n        code.push(' '.repeat(indent + options.indent))\n        code.push(genNode(prop, indent + options.indent, options))\n        code.push('\\n')\n      })\n      shouldIndentClosing = true\n    } else {\n      props.forEach((prop) => {\n        code.push(' ')\n        code.push(genNode(prop, indent, options))\n      })\n    }\n  }\n\n  if (shouldIndentClosing) code.push(' '.repeat(indent))\n  if (node.isSelfClosing) {\n    if (!shouldIndentClosing) code.push(' ')\n    code.push('/>')\n  } else {\n    code.push('>', genChildren(node, indent, options), '</', node.tag, '>')\n  }\n\n  return code.join('')\n}\n\nfunction genChildren(\n  node: ElementNode | RootNode,\n  indent: number,\n  options: StringifyOptions,\n): string {\n  const code: string[] = []\n  const children = applyReplaceNodes(node.children, options)\n  if (children.length > 0) {\n    const hasOnlyInlineChildren = children.every(\n      (child) => !isElementNode(child),\n    )\n    if (hasOnlyInlineChildren) {\n      children.forEach((child) => {\n        code.push(genNode(child, indent + options.indent, options))\n      })\n    } else {\n      let wasLastChildInline = true\n      children.forEach((child) => {\n        if (isTextNode(child) && child.content.trim() === '') return // Ignore empty text nodes.\n        const isThisChildInline = !isElementNode(child)\n        if (wasLastChildInline && isThisChildInline) {\n          // No need to put anything between inline children.\n        } else if (wasLastChildInline) {\n          code.push('\\n')\n        } else if (isThisChildInline) {\n          code.push('\\n', ' '.repeat(indent + options.indent))\n        } else {\n          code.push('\\n')\n        }\n\n        code.push(genNode(child, indent + options.indent, options))\n        wasLastChildInline = isThisChildInline\n      })\n      code.push('\\n', ' '.repeat(indent))\n    }\n  }\n  return code.join('')\n}\n\nfunction applyReplaceNodes(nodes: Node[], options: StringifyOptions): Node[] {\n  return nodes\n    .map((node) => {\n      if (options.replaceNodes.has(node)) return options.replaceNodes.get(node)\n      return node\n    })\n    .filter(Boolean) as Node[]\n}\n\nfunction genDirectiveNode(\n  node: DirectiveNode,\n  indent: number,\n  options: StringifyOptions,\n): string {\n  const code: string[] = []\n\n  if (options.directive === 'shorthand' && node.name in shorthands) {\n    code.push(shorthands[node.name as 'bind' | 'on' | 'slot'])\n  } else {\n    code.push(`v-${node.name}`)\n    if (node.arg != null) code.push(':')\n  }\n\n  if (isSimpleExpressionNode(node.arg)) {\n    if (node.arg.isStatic) code.push(genNode(node.arg, indent, options))\n    else code.push('[', genNode(node.arg, indent, options), ']')\n  }\n\n  node.modifiers.forEach((modifier) => code.push('.', modifier))\n\n  if (isSimpleExpressionNode(node.exp)) {\n    code.push('=\"', genNode(node.exp, indent, options), '\"')\n  }\n\n  return code.join('')\n}\n\nfunction genAttributeNode(\n  node: AttributeNode,\n  indent: number,\n  options: StringifyOptions,\n): string {\n  return node.value != null\n    ? `${node.name}=\"${genNode(node.value, indent, options)}\"`\n    : node.name\n}\n"],"names":["_isSimpleIdentifier","_createSimpleExpression"],"mappings":"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"}